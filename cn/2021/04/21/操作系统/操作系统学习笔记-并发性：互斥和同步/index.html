<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统学习笔记-并发性：互斥和同步 | 花猪のBlog</title><meta name="keywords" content="操作系统"><meta name="author" content="花猪,2296412185@qq.com"><meta name="copyright" content="花猪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录操作系统学习历程">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统学习笔记-并发性：互斥和同步">
<meta property="og:url" content="https://cnhuazhu.github.io/2021/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="花猪のBlog">
<meta property="og:description" content="记录操作系统学习历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png">
<meta property="article:published_time" content="2021-04-21T11:55:33.000Z">
<meta property="article:modified_time" content="2021-06-23T09:28:38.901Z">
<meta property="article:author" content="花猪">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/avatar.jpg"><link rel="canonical" href="https://cnhuazhu.github.io/2021/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%9A%E4%BA%92%E6%96%A5%E5%92%8C%E5%90%8C%E6%AD%A5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":60,"languages":{"author":"作者: 花猪","link":"链接: ","source":"来源: 花猪のBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#ABADAC","bgDark":"#121212","position":"bottom-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统学习笔记-并发性：互斥和同步',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-23 17:28:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/tag.css"><link rel="stylesheet" href="/css/pagelucency.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="stylesheet" href="/css/avatarbg.css"><link rel="stylesheet" href="/css/footerlucency.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="花猪のBlog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top/"><i class="fa-fw fas fa-gift"></i><span> 引导</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-sitemap"></i><span> 分站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top/next"><i class="fa-fw fas fa-chevron-right"></i><span> Next</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fa fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/website/"><i class="fa-fw fas fa-globe"></i><span> 网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">花猪のBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top/"><i class="fa-fw fas fa-gift"></i><span> 引导</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-sitemap"></i><span> 分站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top/next"><i class="fa-fw fas fa-chevron-right"></i><span> Next</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i><span> 电影</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fa fa-video"></i><span> 视频</span></a></li><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-quote-left"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/website/"><i class="fa-fw fas fa-globe"></i><span> 网站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统学习笔记-并发性：互斥和同步</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-21T11:55:33.000Z" title="发表于 2021-04-21 19:55:33">2021-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-23T09:28:38.901Z" title="更新于 2021-06-23 17:28:38">2021-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统学习笔记-并发性：互斥和同步"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>前言</h1>
<p><em>正在学习操作系统，记录笔记。</em></p>
<blockquote>
<p>参考资料：</p>
<p>《操作系统（精髓与设计原理 第6版） 》</p>
</blockquote>
<hr>
<h1>第五章：并发性：互斥和同步</h1>
<p>操纵系统设计中的核心问题就是关于进程和线程的管理（包括以下三个方面）：</p>
<ul>
<li>多道程序设计技术：管理单处理器系统中的多个进程。</li>
<li>多处理技术：管理多处理器系统中的多个进程。</li>
<li>分布式处理技术：管理多台分布式计算机系统中多个进程的执行。</li>
</ul>
<p>支持并发进程的基本要求是加强**互斥（Mutual exclusion）**的能力（即排他性），具体表现为：当一个进程被授予互斥能力时，在该进程的访问共享资源（如文件、I/O访问）的活动期间，不允许其它进程访问该资源。</p>
<p>为了实现互斥，根据上述提到的三类多进程技术，这里会介绍三种实现互斥的方案：<strong>信号量（Semaphores）、管程（Monitors）、消息传递（Message Passing）</strong>。</p>
<p>在正式介绍本章内容之前先理解以下两个部分的内容👇👇👇👇</p>
<p>首先要了解并发可以在三种平台以三种方式进行：</p>
<ul>
<li>
<p>三种平台：</p>
<ol>
<li>在单处理器上，并发执行（交替）；</li>
<li>在多处理器平台上，并行执行；</li>
<li>在分布式系统中，并行执行。</li>
</ol>
</li>
<li>
<p>三种执行方式：</p>
<ol>
<li>
<p>多个应用程序，并发执行，以提升计算机系统的运行效率。</p>
<blockquote>
<p>比如开着QQ音乐，浏览新闻，同时开着微信与朋友聊天。</p>
</blockquote>
</li>
<li>
<p>结构化程序：将一个程序采用模块化设计，然后用多线程的方式并发执行。</p>
<blockquote>
<p>比如色情图像检测模块，我们分为关键帧抽取模块，检测模块与用户响应模块，将三个模块并发执行减少系统的响应时间。</p>
</blockquote>
</li>
<li>
<p>在操作系统中采用并发方式，提升操作系统的效率；</p>
</li>
</ol>
</li>
</ul>
<p>接着了解下和并发相关的关键术语：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子操作（Atomic operation）</td>
<td>一个或多个指令的序列，对外是不可分的；即没有其他进程可以看到其中间状态或者中断此操作（指令集合在执行时不允许被中断，要么就全部执行，要么就不执行）</td>
</tr>
<tr>
<td>临界区（Critical section）</td>
<td>是一段代码，在这段代码中进程将访问共享资源，当另外一个进程已经在这段代码中运行时，这个进程就不能在这段代码中执行</td>
</tr>
<tr>
<td>死锁（Deadlock）</td>
<td>两个或两个以上的进程因其中的每个进程都在等待其他进程做完某些事情而不能继续执行，这样的情形叫做死锁（比如只能通过一辆汽车的公路上，两辆汽车相向而行）</td>
</tr>
<tr>
<td>活锁（Livelock）</td>
<td>两个或两个以上进程为了响应其他进程中的变化而持续改变自己的状态但不做有用的工作，这样的情形叫做活锁（同样是两个并发的进程可能会死锁，但是其中一个进程会主动改变状态）</td>
</tr>
<tr>
<td>互斥（Mutual exclusion）</td>
<td>当一个进程在临界区访问共享资源时，其他进程不能进入该临界区访问任何共享资源，这种情形叫做互斥（排他性）</td>
</tr>
<tr>
<td>竞争条件（Race condition）</td>
<td>多个线程或者进程在读写一个共享数据时，结果依赖于它们执行的相对时间，这种情形叫做竞争（共享资源的状态由最后执行的进程决定的情形）</td>
</tr>
<tr>
<td>饥饿（Starvation）</td>
<td>是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况</td>
</tr>
</tbody>
</table>
<blockquote>
<p>从临界区中我们又可以引出<strong>临界资源</strong>的概念：两个或多个进程需要访问的一个不可共享的资源。</p>
</blockquote>
<h2 id="并发的原理">并发的原理</h2>
<p>在操作系统中引入并发的<strong>根本目的是为了提高计算机的运行效率</strong>，并发在三种硬件平台上有两种形式：<code>Concurrency（并发）</code>与<code>Parallel（并行）</code>,：</p>
<ul>
<li>并发：指的是在同一个时间段内有多个进程在CPU上交替执行，因为计算机执行速度快，人的反应慢，并发给人一种错觉就是在这个时间段内多个程序同时进行。</li>
<li>并行：指的是在同一个时刻多个进程同时在执行，这个同时执行就是物理存在而不是虚拟的。</li>
</ul>
<p>下面两张图可以较为直观的理解并发的原理：</p>
<ul>
<li>
<p>在单处理器多道程序设计系统中（图左，<strong>并发</strong>）：进程交替执行，表现出一种同时执行的外部特征。（并未实现真正意义上的并行处理）</p>
<blockquote>
<p>即使不能实现真正的并行处理，并且在进程间来回切换也需要一定的开销，交替执行在处理效率和程序结构上还是带来了重要的好处。</p>
</blockquote>
</li>
<li>
<p>在多处理系统中（图右，<strong>并行</strong>）：进程不仅可以交替执行，而且可以重叠执行。（能够实现真正意义上的并行处理）</p>
<blockquote>
<p>从表面上看，交替和重叠代表了完全不同的执行模式和不同的问题。但实际上两种技术都可以看做是并发处理的一个实例，且都代表了同样的问题。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E8%BF%9B%E7%A8%8B.png" alt=""></p>
</li>
</ul>
<p>由于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测。（它取决于其他进程的活动、操作系统处理中断的方式、操作系统的调度策略）会导致并发面临以下问题：</p>
<ul>
<li>中断性（破坏了连续性）：为了实现并发，进程交替执行，所以在进程并发执行过程中，进程的执行是走走停停的；</li>
<li>失去了封闭性：计算机资源在一个时间段内是为所有的进程所独有；</li>
<li>执行的不一致性：在相同的输入下，进程执行可能会产生不同的结果。</li>
</ul>
<h3 id="简单案例及分析">简单案例及分析</h3>
<p>为了更好理解这章的关键，考虑下面一个简单的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chin = getchar();</span><br><span class="line">	chout = chin;</span><br><span class="line">	<span class="built_in">putchar</span>(chout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个过程显示了字符回显程序的基本步骤，每当击一下键，就可从键盘获得输入。每个输入字符就保存在变量chin中，然后传送给变量chout，并回送给显示器。任何程序可以重复地调用这个过程，接收用户输入，并在屏幕上显示。</p>
</blockquote>
<p>假定博主本人使用的是一个支持单用户的单处理器多道程序设计系统，我要同时使用多个应用程序，而且每个应用程序都要使用同一个键盘输入，同一块显示器输出，因此每个应用程序都需要使用这个<code>echo()</code>函数。为了节省空间，我会把这个程序载入到一个所有应用程序都可以访问的全局存储区域。这种设计一方面节省了空间，另一方面允许各个进程间有效而紧密的交互。但是这样的设计也会带来一些问题，考虑以下P1和P2进程的执行顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E6%A1%88%E4%BE%8B%E8%BF%87%E7%A8%8B%E4%B8%80.png" alt=""></p>
<ol>
<li>进程P1调用echo过程，并在getchar返回它的值以及将该值存储于chin后立即被中断，此时，最近输入的字符x保存在变量chin中。</li>
<li>进程P2被激活并调用echo过程，echo过程运行得出结果，输入，然后在屏幕上显示单个的字符y。</li>
<li>进程P1被恢复。此时chin中的值x被写覆盖，因此已丢失，而chin中的值y被传送给chout并显示出来。</li>
</ol>
<p>最终造成的结果就是第一个字符x丢失，第二个字符y被显示了两次。</p>
<blockquote>
<p>问题的本质在于共享全局变量chin。多个进程访问这个全局变量，如果一个进程修改了它，然后被中断，那么另一个进程可能在第一个进程使用它的值之前又修改了这个变量。</p>
</blockquote>
<p>假设在这个过程中一次只可以有一个进程，那么前面的顺序会产生如下结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E6%A1%88%E4%BE%8B%E8%BF%87%E7%A8%8B%E4%BA%8C.png" alt=""></p>
<ol>
<li>进程P1调用echo过程，并在输入函数取得结果后立即被中断，此时，最近输入的字符x保存在变量chin中。</li>
<li>进程P2被激活并调用echo过程。但是，由于P1仍然在echo过程中，尽管当前P1处于挂起状态，P2仍被阻塞，不能进入这个过程。因此，P2被挂起，等待echo过程可用。</li>
<li>一段时间后，进程P1被恢复，完成echo的执行，并显示出正确的字符x。</li>
<li>当P1退出echo后，解除了对P2的阻塞，P2被恢复，成功地调用echo过程。</li>
</ol>
<p>这样的输出结果是我们所希望的。</p>
<p>上述这个简单的案例说明，如果需要保护共享的全局变量（以及其他共享的全局资源），唯一的办法是控制访问该变量的代码。如果我们定义了一条规则，一次只允许一个进程进入echo，并且只有在echo过程运行结束后它才对另一个进程是可用的，那么刚才讨论的那类错误就不会发生了。</p>
<p>如何实施此规则是本章的重要内容！！！！</p>
<blockquote>
<p>上述我们讨论的情况是在单处理器多道程序设计系统中，但其实在多处理器系统中，同样也存在保护共享资源的问题，其解决方法也是相同的：<strong>控制对共享资源的访问</strong>。</p>
</blockquote>
<h3 id="竞争条件">竞争条件</h3>
<p>竞争条件发生在多个进程或线程读写数据时，其最终的结果依赖于多个进程的<strong>指令执行顺序</strong>。</p>
<blockquote>
<p>考虑下面两个简单的例子：</p>
<ul>
<li>
<p>案例一：</p>
<p>假设两个进程P1和P2共享全局变量a。在某一执行时刻，P1更新a为1，在执行的另外某一时刻，P2更新a为2。因此，两个任务竞争更新变量a。</p>
<p>（在本例中，竞争的“失败者”（也就是最后更新全局变量a的进程）决定了变量a的最终值。）</p>
</li>
<li>
<p>案例二：</p>
<p>考虑两个进程P3和P4共享全局变量b和c，并且初始值b=1，c=2。在某一执行时刻，P3执行赋值语句b=b+c，在另一执行时刻，P4执行赋值语句 c=b+c。两个进程更新不同的变量，但两个变量的最终值依赖于两个进程执行赋值语句的顺序。如果P3首先执行赋值语句，那么最终的值为b=3，c=5。如果P4首先执行赋值语句，那么最终的值为b=4，c=3。</p>
</li>
</ul>
</blockquote>
<h3 id="操作系统关注的问题">操作系统关注的问题</h3>
<p>并发会带来如下设计和管理问题：</p>
<ol>
<li>
<p>操作系统需要进程控制块（PCB）来记住各个活跃的进程。</p>
</li>
<li>
<p>操作系统必须为每个活跃进程分配和释放各种资源（因为进程是资源的分配单位），这些资源包括：</p>
<ul>
<li>处理器时间：这是调度功能。</li>
<li>存储器：大多数操作系统使用虚拟存储方案。</li>
<li>文件</li>
<li>I/O设备</li>
</ul>
</li>
<li>
<p>操作系统必须保护每个进程的数据和物理资源，避免其他进程的无意干涉。</p>
</li>
<li>
<p>一个进程的功能和输出结果必须与执行速度（相对于其他并发进程的执行速度）无关。【本章关键就是介绍如何实现这一点】</p>
<blockquote>
<p>关于如何实现上述第四点，这里给出两种解决方案：</p>
<ul>
<li>取消共享资源：每个进程和每个线程所用到的资源都是独享的，这种方法能够解决前面的问题，但是和操作系统的设计目标不符合（操作系统是资源的管理者，要让计算机系统中的资源得到充分使用）</li>
<li>让进程和线程的执行顺序满足一定的条件（同步和互斥，核心概念是互斥）</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="进程的交互">进程的交互</h3>
<p>根据进程相互间是否指导对方存在的程度，对进程间的交互方式进行如下三种分类：</p>
<ul>
<li>
<p>进程之间相互不知道对方的存在</p>
<p>这是一些独立的进程，它们不会一起工作。关于这种情况的最好例子是多个独立进程的多道程序设计，可以是批处理作业，也可以是交互式的会话，或者是两者的混合。尽管这些进程不会一起工作，但操作系统需要知道它们对资源的竞争情况。（例如，两个无关的应用程序可能都想访问同一个磁盘、文件或打印机，操作系统必须控制这样的访问）</p>
</li>
<li>
<p>进程间接知道对方的存在</p>
<p>这些进程并不需要知道对方的进程ID，但它们共享某些对象，如一个I/O缓冲区。这类进程在共享同一个对象时表现出合作行为。</p>
</li>
<li>
<p>进程直接知道对方的存在</p>
<p>这些进程可以通过进程ID互相通信，用于合作完成某些活动。同样，这类进程表现出合作行为。</p>
</li>
</ul>
<p>下面的表格更为详细地说明了进程间的三种交互方式：</p>
<table>
<thead>
<tr>
<th>知晓程度</th>
<th>关系</th>
<th>一个进程对其他进程的影响</th>
<th>潜在的控制问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>进程之间相互不知道对方的存在</td>
<td>竞争</td>
<td>·一个进程的结果与其他进程的活动无关<br/>·进程的执行时间可能会受到影响</td>
<td>·互斥<br/>·死锁（可复用的资源）<br/>·饥饿</td>
</tr>
<tr>
<td>进程间接知道对方的存在（如共享对象）</td>
<td>通过共享合作</td>
<td>·一个进程的结果可能依赖于从其他进程获得的信息<br/>·进程的执行时间可能会受到影响</td>
<td>·互斥<br/>·死锁（可复用的资源）<br/>·饥饿<br/>·数据一致性</td>
</tr>
<tr>
<td>进程直接知道对方的存在（它们有可用的通信原语）</td>
<td>通过通信合作</td>
<td>·一个进程的结果可能依赖于从其他进程获得的信息<br/>·进程的计时可能会受到影响</td>
<td>·死锁（可消费的资源）<br/>·饥饿</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对上述表格中不同关系存在的控制问题做一个详细补充：</p>
<ul>
<li>进程之间相互不知道对方的存在：
<ul>
<li>互斥：虽然进程互不知道，但是由于在同一个计算机系统中，对于临界资源需要互斥访问；</li>
<li>死锁：互斥的进程相互竞争资源，导致所需的资源无法有效释放；</li>
<li>饥饿：进程具备执行条件，但是由于得不到资源无法执行（低优先级的进程在执行时，前面老有高优先级的进程。）</li>
</ul>
</li>
<li>进程间接知道对方的存在：
<ul>
<li>因为进程间存在共享资源的关系，所以“互不知道关系”的三个问题它都具有；</li>
<li>同时它还多了一个数据的不一致性问题（条件竞争）</li>
</ul>
</li>
<li>进程直接知道对方的存在：
<ul>
<li>死锁：错误的同步，导致两个进程同时等待对方发消息；</li>
<li>饥饿：多个并发执行的进程，某一个进程始终没有得到让他启动的消息。</li>
</ul>
</li>
</ul>
<p>实际条件并不总是像上表中给出的那么清晰，几个进程可能既表现出竞争，又表现出合作。然而，对操作系统而言，分别检查表中的每一项并确定它们的本质是必要的。</p>
</blockquote>
<h4 id="进程间的资源竞争">进程间的资源竞争</h4>
<p>当并发进程竞争使用同一资源时，它们之间就会发生冲突。（这类资源包括I/O设备、存储器、处理器时间和时钟）</p>
<p>竞争进程面临以下三个控制问题：</p>
<ul>
<li>
<p>互斥：</p>
<p>一次只允许有一个程序在临界区中。（例如，每次只允许一个进程向打印机发送命令）</p>
</li>
<li>
<p>死锁：</p>
<p>考虑两个进程P1和P2，以及两个资源R1和R2。假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把R1分配给P2，把R2分配给P1，每个进程都在等待另一个资源，且在获得其他资源并完成功能前，谁都不会释放自己已经拥有的资源。这两个进程发生死锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E7%AB%9E%E4%BA%89.png" alt=""></p>
</li>
<li>
<p>饥饿：</p>
<p>假设有三个进程（P1、P2和P3），每个进程都周期性地访问资源R。考虑这种情况，P1拥有资源，P2和P3都被延迟，等待这个资源。当P1退出它的临界区时，P2和P3都被允许访问R。假设操作系统把访问权授予P3，并且在P3完成临界区之前P1又需要访问该临界区。如果在P3结束后操作系统又把访问权授予P1，并且接下来把访问权轮流授予P1和P3，那么即使没有死锁，P2也可能被无限期地拒绝访问资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E9%A5%A5%E9%A5%BF.png" alt=""></p>
</li>
</ul>
<blockquote>
<p>下图用抽象术语给出了互斥机制。假设有n个进程并发执行，每个进程都包括了在某资源Ra上操作的临界区以及不涉及资源Ra的替它代码。因为所有的进程都需要访问同一个资源Ra，因此在某一时刻只有一个进程在临界区是很重要的。</p>
<p>为实施互斥，需要两个函数：<code>entercritical</code>和<code>exitcritical</code>。每个函数的参数都是竞争使用的资源名。如果一个进程在它的临界区中，那么其他任何试图进入临界区的进程都必须等待。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E7%AB%9E%E4%BA%892.png" alt=""></p>
</blockquote>
<h4 id="进程间通过共享合作">进程间通过共享合作</h4>
<p>通过共享进行合作的情况，包括进程间在互相并不确切知道对方的情况下进行交互。</p>
<p>例如，多个进程可能访问一个共享变量、共享文件或数据库，进程可能使用并修改共享变量而不涉及其他进程，但却知道其他进程也可能访问同一个数据。因此，这些进程必须合作，以确保它们共享的数据得到正确的管理。控制机制必须必须确保共享数据的完整性。</p>
<h4 id="进程间通过通信合作">进程间通过通信合作</h4>
<p>当进程通过通信进行合作时，各个进程都与其他进程进行连接，通信提供了同步和协调各种活动的方法。</p>
<blockquote>
<p>在典型情况下，通信可由各种类型的消息组成，发送消息和接收消息的原语由程序设计语言提供，或者由操作系统的内核提供。</p>
<p>由于在传递消息的过程中进程间没有共享任何对象，因而这类合作不需要互斥，但是仍然存在死锁和饥饿的问题。</p>
</blockquote>
<h3 id="互斥的要求">互斥的要求</h3>
<p>为了提供对互斥的支持，必须满足以下要求（十六字简记）：</p>
<ul>
<li>
<p>空闲让进：如果没有进程访问临界资源，如果没有进程访问，可以允许访问；</p>
</li>
<li>
<p>忙则等待：如果有进程访问，则申请访资源的进程保持等待；</p>
</li>
<li>
<p>有限等待：对于申请访问临界资源的进程，应该在有限的时间内实现对临界资源的访问，避免死锁和饥饿的发生；</p>
</li>
<li>
<p>让权等待：申请临界资源的进程如果不能马上访问临界资源，应该立即释放CPU的使用权给其他进程。</p>
<blockquote>
<p>能过满足以上互斥要求的方法主要有三类：</p>
<ul>
<li>
<p>方法一：让由并发执行的进程担负这个责任。（软件方法）</p>
<p>这类进程，不论是系统程序还是应用程序，都需要与另一个进程合作，而不需要程序设计语言或操作系统提供任何支持来实施互斥。（该方法已被证明会增加开销和缺陷）</p>
</li>
<li>
<p>方法二：专用的机器指令，保证原子操作实现互斥。（硬件方法）</p>
<p>这种方法的优点是可以减少开销，但却很难成为一种通用的解决方案。</p>
</li>
<li>
<p>方法三：由操作系统或编译器提供工具或方法实现，主要有三种：信号量，管程和消息。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="互斥：硬件的支持">互斥：硬件的支持</h2>
<p>许多增强互斥的软件算法已经开发出来了。软件方法会带来高开销并且很容易产生逻辑错误。这一部分我们来讨论提供互斥的硬件支持。</p>
<h3 id="中断禁用">中断禁用</h3>
<p>前文介绍过，在单处理机器中，并发进程不能重叠，只能交替。一个进程直到它调用了一个操作系统服务或者被中断，它将一直运行。因此为了保证互斥，只需要保证一个进程不被中断就可以了。</p>
<blockquote>
<p>思路：</p>
<ol>
<li>进入访问临界资源之前，让中断失效；</li>
<li>访问完临界资源之后，使能中断；</li>
</ol>
</blockquote>
<p>这种能力可以通过系统内核为启用和禁用中断定义的原语来提供。一个进程可以通过下面的方法实施互斥：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*disable interrupts（禁用中断）*/</span></span><br><span class="line">	<span class="comment">/*critical section（临界区）*/</span></span><br><span class="line">	<span class="comment">/*enable interrupts（启用中断）*/</span></span><br><span class="line">	<span class="comment">/*remainder（其余部分）*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中断禁用的方法使得程序执行到临界区之前不能被其他进程打断，因此可以保证互斥。但是这种方法也有两种缺陷：</p>
<ul>
<li>限制了进程的并发执行：这会导致计算机系统的执行效率有明显的降低。（与原本并发的初衷相悖）</li>
<li>在多核计算机或分布式系统中，这种方法可能失效，因为屏蔽中断需要向多个CPU同时发起，屏蔽中断信号的发送有一个时延，这个时延可能导致互斥的失效；</li>
</ul>
<h3 id="专用机器指令">专用机器指令</h3>
<p>在多处理器系统中，多个处理器共享内存，这种情况处理器之间的行为是无关的，它们之间也没有支持互斥的中断机制。但是在硬件级别上，我们可以追求对存储单元的访问排斥对相同单元的其他访问。基于这一点，处理器的设计者提出了一些机器指令，用于保证两个动作的原子性。</p>
<blockquote>
<p>原子性：“原子”表示不能被中断的单个步骤的指令。</p>
<p>例如在一个取指令周期中对一个存储器单元的读和写或者读和测试。在该指令执行的过程中，任何其他的指令访问内存将被阻止。而这些动作在一个指令周期中完成。</p>
</blockquote>
<p>接下来会介绍两种常见的指令：</p>
<h4 id="compare-and-swap（比较和交换指令）">compare_and_swap（比较和交换指令）</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare_and_swap</span> <span class="params">(<span class="keyword">int</span> *word, <span class="keyword">int</span> testval, <span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldval;</span><br><span class="line">    oldval = *word;</span><br><span class="line">    <span class="keyword">if</span> (oldval == testval) *word = newval;</span><br><span class="line">    <span class="keyword">return</span> oldval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码为<code>比较和交换</code>指令的一个版本：</p>
<ul>
<li>用一个测试值（teatval）检查一个内存单元（*word）。如果该内存单元的当前值是testval，就用newval取代该值；否则保持不变。</li>
<li>该指令总是返回旧内存值；因此，如果返回值与测试值相同，则表示该内存单元已被更新。</li>
<li>（这个原子指令由两个部分组成：比较内存单元值和测试值；如果值有差异，则产生交换。整个比较和交换功能按原子操作执行，即它不接受中断。）</li>
</ul>
<p>该指令的另一个版本返回一个布尔（Boolean）值：交换发生时为真（true）；否则为假（false）。</p>
<p>（几乎所有处理器家族（x86、IA64、sparc、/390等）中都支持该指令的某个版本，而且多数操作系统都利用该指令支持并发。）</p>
</blockquote>
<p>下面的代码将展示基于使用<code>比较和交换</code>指令的互斥规程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program mutualexclusion*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程个数*/</span>;</span><br><span class="line"><span class="keyword">int</span> bolt; <span class="comment">/*共享变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (compare_and_swap(bolt,<span class="number">0</span>,<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">/*不做任何事*/</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*临界区*/</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*其余部分*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = o; <span class="comment">/*初始化共享变量*/</span></span><br><span class="line">    parbegin (P(<span class="number">1</span>), P(<span class="number">2</span>),...,P(n)); <span class="comment">/*多个进程并发*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>共享变量bolt被初始化为0。唯一可以进入临界区的进程是发现bolt等于0的那个进程。所有试图进入临界区的其他进程进入忙等待模式。</p>
<p>忙等待（busy waiting）/自旋等待（spin waiting）：</p>
<p>进程在得到临界区访问权之前，它只能继续执行测试变量的指令来得到访问权，除此之外不能做其他事情。</p>
<p>当一个进程离开临界区时，它把bolt重置为0，此时只有一个等待进程被允许进入临界区。进程的选择取决于哪个进程正好执行紧接着的<code>比较和交换</code>指令。</p>
</blockquote>
<h4 id="exchange（交换指令）">exchange（交换指令）</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> <span class="keyword">register</span>, <span class="keyword">int</span> memory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = memory;</span><br><span class="line">    memory = <span class="keyword">register</span>;</span><br><span class="line">    <span class="keyword">register</span> = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该指令交换一个寄存器的内容和一个存储单元的内容。</p>
</blockquote>
<p>下面的代码将展示基于<code>exchange</code>指令的互斥协议：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program mutualexclusion*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> n = <span class="comment">/*进程个数*/</span>;</span><br><span class="line"><span class="keyword">int</span> bolt; <span class="comment">/*共享变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keyi = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">do</span> <span class="title">exchange</span> <span class="params">(keyi, bolt)</span></span></span><br><span class="line"><span class="function">        <span class="title">while</span> <span class="params">(keyi != <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">/*临界区*/</span>;</span><br><span class="line">        bolt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*其余部分*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bolt = o; <span class="comment">/*初始化共享变量*/</span></span><br><span class="line">    parbegin (P(<span class="number">1</span>), P(<span class="number">2</span>),...,P(n)); <span class="comment">/*多个进程并发*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>共享变量bolt被初始化为0，每个进程都使用一个局部变量key且初始化为1。唯一可以进入临界区的进程是发现bolt等于0的那个进程。它通过把bolt置为1排斥所有其他进程进入临界区。当一个进程离开临界区时，它把bolt重置为0，允许另一个进程进入它的临界区。</p>
</blockquote>
<p>机器指令方法的优点：</p>
<ul>
<li>适用于在单处理器或共享内存的多处理器上的任何数目的进程。</li>
<li>非常简单且易于实现。</li>
<li>可用于支持多个临界区，每个临界区可以用它自己的变量定义。</li>
</ul>
<p>机器指令方法的缺点：</p>
<ul>
<li>
<p>使用了忙等待：</p>
<p>当一个进程正在等待进入临界区时，它会继续消耗处理器时间。</p>
</li>
<li>
<p>可能导致饥饿：</p>
<p>当一个进程离开一个临界区并且有多个进程正在等待时，选择哪一个等待进程是任意的，因此，某些进程可能被无限期地拒绝进入。</p>
</li>
<li>
<p>可能导致死锁：</p>
<p>考虑单处理器中的下列情况。进程P1执行专门指令（如compare&amp;swap、exchange）并进入临界区，然后P1被中断并把处理器让给具有更高优先级的P2。如果P2试图使用同一资源，由于互斥机制，它将被拒绝访问。因此，它会进入忙等待循环。但是，由于P1比P2的优先级低，它将永远不会被调度执行。</p>
</li>
</ul>
<h2 id="信号量">信号量</h2>
<p><em>敲黑板！！！！（重点来啦！！！！</em></p>
<p>信号量是1965年由荷兰科学家迪杰斯特拉提出来的（数据结构最短路径算法的提出者），信号量的本质是一种数据结构，用来处理并发进程之间的互斥与同步的。</p>
<blockquote>
<p>在详细介绍信号量之前我们先了解一下常用的并发机制：</p>
<table>
<thead>
<tr>
<th>并发机制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>信号量（Semaphore）</td>
<td>用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行，<strong>初始化</strong>、<strong>递减</strong>和<strong>增加</strong>，这三种操作都是原子操作。递减操作可以用于阻塞一个进程，增加操作可以用于解除阻塞一个进程。也称为<strong>计数信号量</strong>或<strong>一般信号量</strong></td>
</tr>
<tr>
<td>二元信号量（Binary semaphore）</td>
<td>只取0值和1值的信号量</td>
</tr>
<tr>
<td>互斥量（Mutex）</td>
<td>类似于二元信号量。关键区别在于为其加锁（设定值为0）的进程和为其解锁（设定值为1）的进程必须为同一个进程</td>
</tr>
<tr>
<td>条件变量（Condition variable）</td>
<td>一种数据类型。用于阻塞进程或者线程，直到特定的条件为真</td>
</tr>
<tr>
<td>管程（Monitor）</td>
<td>一种编程语言结构，在一个抽象数据类型中封装了变量、访问过程和初始化代码。管程的变量只能由管程自己的访问过程来访问，每次只能有一个进程在其中执行。访问过程即临界区。管程可以有一个等待进程队列</td>
</tr>
<tr>
<td>事件标志（Event flags）</td>
<td>作为同步机制的一个内存字。应用程序代码可以为标志中的每个位关联不同的事件。通过测试相关的一个或多个位，线程可以等待一个事件或多个事件。在全部的所需位都被设定（AND）或者至少一个位被设定（OR）之前线程会一直被阻塞</td>
</tr>
<tr>
<td>信箱/消息（Mailboxes/messages）</td>
<td>两个进程交换信息的一种方法，也可以用于同步</td>
</tr>
<tr>
<td>自旋锁（Spinlocks）</td>
<td>一种互斥机制，进程在一个无条件循环中执行，等待锁变量的值变为可用</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="基本原理">基本原理</h3>
<p>两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。（任何复杂的合作需求都可以通过适当的信号结构得到满足）</p>
<h3 id="信号量的结构">信号量的结构</h3>
<p>信号量的结构包括两个成员和两个原子操作：</p>
<ul>
<li>
<p>两个成员：</p>
<ul>
<li>整形变量count：我们可以对这个信号量进行初始化，用来表明共享资源的数目或者是进程执行的状态。</li>
<li>队列：用来存放因为使用了某种操作导致进程阻塞在该信号量的进程。</li>
</ul>
</li>
<li>
<p>两个原子操作：</p>
<ul>
<li><code>semWait(x)</code>: semWait 对 count 进行<strong>减一</strong>操作，如果操作结果为负数（<strong>小于零</strong>)，执行semWait 的进程会被阻塞到队列上；</li>
<li><code>semSingal(x)</code>:semsignal对count进行<strong>加一</strong>操作，如果执行后的结果<strong>小于等于零</strong>，会从阻塞队列的队首的进程出队，并变为就绪状态。</li>
</ul>
<blockquote>
<p>上面的概念定义了一般信号量的概念，下面还有几个衍生的概念：</p>
<ul>
<li>计数信号量：如果count的取值是整个整数空间；</li>
<li>二元信号量：如果count的取值仅限于0和1；</li>
<li>互斥信号量：如果信号量中的semWait和semSignal操作在一个进程之内；</li>
<li>强信号量：信号量中阻塞的进程拥有明确的出队队列；</li>
<li>弱信号量：阻塞进程的出队策略不明确（一会FIFO，一会基于优先级）</li>
</ul>
</blockquote>
</li>
</ul>
<p>说明：</p>
<p>对以上操作的解释如下：</p>
<ul>
<li>
<p>开始时，信号量的值为零或者是正数；</p>
</li>
<li>
<p>如果该值为正数，则该值等于发出semWait操作后可立即继续执行的进程的数量；</p>
</li>
<li>
<p>如果该值为零（或者由于初始化，或者由于有等于信号量初值的进程已经等待），则发出semWait操作的下一个进程会被阻塞，此时该信号量的值变为负值。（之后，每个后续的semWait操作都会使信号量的负值更大，）该负值等于正在等待解除阻塞的进程的数量；</p>
</li>
<li>
<p>在信号量为负值的情形下，每一个semSignal操作都会将等待进程中的一个进程解除阻塞。</p>
<blockquote>
<p>关于信号量定义的结论：</p>
<ul>
<li>通常，在进程对信号量减1之前，无法提前知道该信号量是否会被阻塞。</li>
<li>当进程对一个信号量加1之后，另一个进程会被唤醒，两个进程继续并发运行。而在一个单处理器系统中，同样无法知道哪一个进程会立即继续运行。</li>
<li>在向信号量发出信号后，不需要知道是否有另一个进程正在等待，被解除阻塞的进程数量或者没有或者是1个。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="信号量的使用">信号量的使用</h3>
<p>如上文所述，引入信号量的的目的是实现同步互斥的，使用信号量的操作一般包含以下两个步骤：</p>
<ol>
<li>分析问题之间进程的关系和种类；</li>
<li>根据进程的关系定义信号量并实现；</li>
</ol>
<p>对于不同的关系，操作方法不同：</p>
<ul>
<li>对于互斥关系：
<ol>
<li>有几个临界资源，就定义几个信号量；</li>
<li>根据问题对信号进行初始化；</li>
<li>使用semWait和semSignal实现对信号量的互斥访问；</li>
</ol>
</li>
<li>对于同步关系（一个进程的执行是另外一个进程执行的先决条件）：
<ol>
<li>分析进程之间的同步关系，有几种关系就定义几个信号量；</li>
<li>根据问题的条件对信号量进行初始化；</li>
<li>调用semwait和semsinal实现同步；（一般两个操作不在相同的进程内）</li>
</ol>
</li>
</ul>
<h3 id="信号量原语的定义">信号量原语的定义</h3>
<p>以下代码给出了关于信号原语更规范的定义。（semWait和semsignal原语被假设是原子操作）</p>
<p>（非二元信号量常常也称为<strong>计数信号量</strong>或者<strong>一般信号量</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*semaphore*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*semWait*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span> (s.count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*把当前进程插入到阻塞队列当中*/</span>;</span><br><span class="line">        <span class="comment">/*阻塞当前进程*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*semSignal*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span> (s.count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/*把进程p从阻塞队列当中移除*/</span>;</span><br><span class="line">        <span class="comment">/*把进程p插入到就绪队列*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二元信号量">二元信号量</h3>
<p>以下代码定义了信号量更为严格的形式，信号量的值只能为0或1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*binary_semaphore*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_semaphore</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>zero, one&#125; value;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*semWaitB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWaitB</span><span class="params">(binary_semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.value == one)&#123;</span><br><span class="line">        s.value = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*把当前进程插入到阻塞队列当中*/</span>;</span><br><span class="line">        <span class="comment">/*阻塞当前进程*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*semSignalB*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignalB</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">queue</span> is empty())&#123;</span><br><span class="line">        s.value = one;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*把进程p从阻塞队列中移除*/</span>;</span><br><span class="line">        <span class="comment">/*把进程p插入到就绪队列*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<ul>
<li>一个二元信号量可以初始化成0或1。</li>
<li>semWaitB操作检查信号的值，如果值为0，那么进程执行aemwaitB就会受阻。如果值为1，那么将值改变为0，并且继续执行该进程。</li>
<li>semSignalB操作检查是否有任何进程在该信号上受阻，如果有，那么通过semWaitB操作，受阻的进程就会被唤醒，如果没有进程受阻，那么值被设置为1。</li>
</ul>
</blockquote>
<h3 id="强、弱信号量">强、弱信号量</h3>
<p>不论是哪一种信号量，都需要使用队列来保存在信号量上等待的进程。这就会产生一个问题：进程按照什么顺序从队列中移出？</p>
<ul>
<li>
<p>强信号量：</p>
<p>最公平的策略是先进先出（FIFO）：被阻塞时间最久的进程最先从队列释放。采用这个策略定义的信号量称为强信号量（strong semaphore）。</p>
</li>
<li>
<p>弱信号量：</p>
<p>没有规定进程从队列中移出顺序的信号量称为弱信号量（weak semaphore）。</p>
</li>
</ul>
<p>下图将展示（强）信号量机制的一个例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E5%BC%BA%E4%BF%A1%E5%8F%B7%E9%87%8F.png" alt=""></p>
<blockquote>
<p>说明：</p>
<ul>
<li>初始时刻①，A正在运行，B、D和C就绪，信号量为1。当A执行一条semWait指令后，信号量减为0，A能继续执行，随后它加入就绪队列。</li>
<li>然后在时刻②时，B正在运行，最终执行一条semWait指令，并被挂起（此时信号量为-1）。</li>
<li>在时刻③时，D被允许运行。</li>
<li>在时刻④时，当D完成一个新结果后，它执行一条semSignal指令，允许B移到就绪队列中。</li>
<li>在时刻⑤时，D加入就绪队列，C开始运行，当它执行semWait指令时被挂起。</li>
<li>类似地，在时刻⑥，A和B运行，且被挂起在这个信号量上，允许D恢复执行。</li>
<li>在时刻⑦，当D有一个结果后，执行一条semSlgnal指令，把C移到就绪队列中。</li>
</ul>
</blockquote>
<h3 id="互斥">互斥</h3>
<p>以下代码给出了一种使用信号量s解决互斥问题的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program mutualexclusion*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span>;</span><br><span class="line">semaphore s = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        semWait(s);</span><br><span class="line">        <span class="comment">/*临界区*/</span>;</span><br><span class="line">        semSignal(s);</span><br><span class="line">        <span class="comment">/*其他部分*/</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin (P(<span class="number">1</span>), P(<span class="number">2</span>),...,P(n)); <span class="comment">/*多进程并发执行*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>设有n个进程，用数组P(i)表示，所有的进程都需要访问共享资源。每个进程中进入临界区前执行semWait(s)，如果s的值为负，则进程被挂起；如果值为1，则s被减为0，进程立即进人临界区；由于s不再为正，因而其他任何进程都不能进入临界区。</p>
<p>可以这样理解，当一个进程想要调用公共资源时，就要发出<code>semWait(s)</code>指令，以获取资源，如果获取不到，则一直调用该指令；一旦获取了该资源，则其他进程无法使用；等到该进程使用完资源后，就会调用<code>semSignal(s)</code>指令，告诉其它进程：“我用完啦，并且把资源交还回公共区域啦。”</p>
<ul>
<li><code>s.count ≥ 0</code>：s.count是可以执行semWait(s)而不被挂起的进程数（如果其间没有semSignal(a)被执行）。这种情形允许信号量支持同步与互斥。</li>
<li><code>s.count&lt;0</code>：s.count的大小是挂起在s.queue队列中的进程数.</li>
</ul>
<p>下图给出了信号量机制执行过程的另一种表述，这里不再说明（<em>看得懂，应该看得懂</em>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%AF%B4%E6%98%8E.png" alt=""></p>
</blockquote>
<h3 id="信号量问题">信号量问题</h3>
<p><em>（为了使得文章整体结构看起来不那么混乱，这里用另一篇文章去综合一些关于信号量的问题，点击下方按钮跳转）</em></p>
<div class="btn-center">
<a class="btn-beautify button--animated block outline orange larger" href="/2021/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" 
  title="点击跳转 至 《信号量相关问题》"><i class="far fa-hand-point-right"></i><span>点击跳转 至 《信号量相关问题》</span></a>
</div>
<h3 id="信号量的实现">信号量的实现</h3>
<p><code>semWait</code>和<code>semSignal</code>操作必须作为原子原语实现。可以通过以下三种方式：</p>
<ul>
<li>通过硬件或固件实现。</li>
<li>通过软件方案实现。（这会伴随处理开销）</li>
<li>对于单处理器系统，可以通过禁用中断的方式实现。</li>
</ul>
<h2 id="管程">管程</h2>
<p>从上述内容可以看出信号量有效地提供了进程间互斥与合作的支持，但实际上信号量对于编写者来说是很困难的，用信号量设计一个正确的程序并非易事：由于信号量分布在整个程序中，使用不当，可能造成程序错误，甚至死锁。下面来看三个错误案例：</p>
<ul>
<li>
<p>错误一：在利用信号量互斥时，误将 semWait与semSignal的顺序颠倒：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semSignal(mutex)</span><br><span class="line"> critical area</span><br><span class="line">semWait(mutex)</span><br></pre></td></tr></table></figure>
<p>这会导致临界访问失效。</p>
</li>
<li>
<p>错误二：在实现互斥时，误将semSigal 写成semWait, 或误将semWait写成semSigal, 导致临界区无法访问，或者临界区被多次访问；</p>
</li>
<li>
<p>错误三: 实现互斥访问的时候，程序遗漏了semWait，操作临界区失效；</p>
</li>
</ul>
<p>基于这种情况，DJstra在1971年提出为每一个共享的资源设立一个秘书管理他的访问的思想。即：一切进程访问共享资源时，必须通过设立的秘书，秘书一次只允许一个进程访问共享资源，通过这种方式，即实现了资源的共享，同时也保证了资源的互斥访问与同步。1973年，汉森和霍尔又将秘书的概念发展成为管程。</p>
<p>管程定义了一组局部数据和内部操作，只有内部操作才能使用局部变量，访问管程的进程通过内部操作访问或修改内容数据，从而实现进程间的互斥与访问。</p>
<blockquote>
<p>管程允许程序员用其锁定任何对象（对类似于链表之类的对象，可以用一个锁锁住整个链表，也可以每个表用一个锁，还可以为表中的每一个元素用一个锁）。</p>
<p>管程天生具有排他性（互斥）。因此程序员只需要在管程当中解决好同步问题，互斥的工作可以完全交由编译器处理。</p>
<p>关于实现管程的同步的措施：</p>
<ol>
<li>一个进程调用管程内的内部操作进入管程后，在管程驻留期间，如果该进程要求的共享资源不满足进程执行的条件，需要将进程阻塞在阻塞队列上，并释放管程的使用权；</li>
<li>当阻塞进程等待的条件满足时，需要将该进程从阻塞队列中移除到就绪队列中，允许该进程能够再次进入管程执行。</li>
</ol>
<p>上述两种机制的实现时通过条件变量和两个内部操作<code>cwait</code> 和<code>csignal</code>实现的（下文将详细介绍）：</p>
<ol>
<li>在管程内设置若干条件变量用来区分不同的条件；</li>
<li>针对条件变量的两个操作 cwait和csignal,cwait 是用来将进程阻塞到对应的条件变量阻塞队列中，csignal是用来将进程从对应的阻塞队列中恢复到就绪队列。</li>
</ol>
</blockquote>
<p>管程本质上也是一种数据结构，包含5个部分：</p>
<ol>
<li>局部变量</li>
<li>内部过程</li>
<li>初始化操作</li>
<li>条件变量</li>
<li>阻塞队列</li>
</ol>
<p>管程具有三个特性：</p>
<ol>
<li>管程的内部数据只能被管程内部的操作访问；</li>
<li>一个进程只能通过管程的内部过程对管程进行访问；</li>
<li>每次最多允许一个进程使用管程的内部操作，即进程互斥的调用内部过程进入管程，其他想进入管程的进程必须在阻塞队列中等待。</li>
</ol>
<h3 id="使用信号的管程">使用信号的管程</h3>
<p>管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：</p>
<ul>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li>
<li>一个进程通过调用管程的一个过程进入管程。</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</li>
</ul>
<p>为了进行并发处理，管程必须包含同步工具。</p>
<blockquote>
<p>例如，假设一个进程调用了管程，并且当它在管程中时必须被挂起，直到满足某些条件。这就需要一种机制，使得该进程不仅被挂起，而且能释放这个管程，以便某些其他的进程可以进入。以后，当条件满足并且管程再次可用时，需要恢复该进程并允许它在挂起点重新进入管程。</p>
</blockquote>
<p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：</p>
<ul>
<li>
<p><code>cwait(c)</code>：调用进程的执行在条件c上挂起，管程现在可被另一个进程使用。</p>
</li>
<li>
<p><code>csignal(c)</code>：恢复执行在cwait之后因为某些条件而挂起的进程。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么也不做。</p>
<blockquote>
<p>注意管程的<code>wait</code>和<code>signal</code>操作与信号量不同：</p>
<p>如果在管程中的一个进程发信号，但没有在这个条件变量上等待的任务，则丢弃这个信号。</p>
</blockquote>
</li>
</ul>
<p>下图给出了一个管程的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E7%AE%A1%E7%A8%8B.png" alt=""></p>
<blockquote>
<p>说明：</p>
<p>尽管一个进程可以通过调用管程的任何一个过程进入管程，但我们仍可以把管程想像成具有一个入口点，并保证一次只有一个进程可以进入。其他试图进入管程的进程被阻塞并加入等待管程可用的进程队列中。当一个进程在管程中时，它可能会通过发送cwalt(x)<br>
把自己暂时阻塞在条件x上，随后它被放入等待条件改变以重新进入管程的进程队列中，在cwalt(x)调用的下一条指令开始恢复执行。</p>
<p>如果在管程中执行的一个进程发现条件变量x发生了变化，它发送csignal(x)，通知相应的条件队列条件已改变。</p>
</blockquote>
<p>以下代码给出了一个使用管程的例子，再次考虑生产者/消费者问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program producerconsumer*/</span></span><br><span class="line">monitor boundedbuffer;          </span><br><span class="line"><span class="keyword">char</span> buffer [N];          <span class="comment">/*分配N个数据项空间*/</span></span><br><span class="line"><span class="keyword">int</span> nextin, nextout;          <span class="comment">/*缓冲区指针*/</span></span><br><span class="line"><span class="keyword">int</span> count;          <span class="comment">/*缓冲区中数据项个数*/</span></span><br><span class="line">cond notfull, notempty;          <span class="comment">/*为同步设置的条件变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == N)&#123;</span><br><span class="line">        cwait(notfull);          <span class="comment">/*缓冲区满，防止溢出*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">/*缓冲区中数据项个数加一*/</span></span><br><span class="line">    csignal(nonempty);          <span class="comment">/*释放任何一个等待的进程*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">        cwait(notempty);          <span class="comment">/*缓冲区空，防止下溢*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;          <span class="comment">/*缓冲区中数据项个数减一*/</span></span><br><span class="line">    csignal(notfull);          <span class="comment">/*释放任何一个等待的进程*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;          <span class="comment">/*管程体*/</span></span><br><span class="line">    nextin = <span class="number">0</span>; nextout = <span class="number">0</span>; count = <span class="number">0</span>;          <span class="comment">/*缓冲区初始化为空*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*producer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        produce(x);</span><br><span class="line">        append(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*consumer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        take(x);</span><br><span class="line">        consume(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parbegin(producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>管程模块boundedbuffer控制着用于保存和取回字符的缓冲区，管程中有两个条件变量（使用结构cond声明）：当缓冲区中至少有增加一个字符的空间时，notfull为真；当缓冲区中至少有一个字符时，notempty为真。</p>
<p>生产者可以通过管程中的过程append往缓冲区中增加字符，它不能直接访问buffer。该过程首先检查条件notfiull，以确定缓冲区是否还有可用空间。如果没有，执行管程的进程在这个条件上被阻塞。其他某个进程（生产者或消费者）现在可以进入管程。然后，当缓冲区不再满时，被阻塞进程可以从队列中移出，重新被激活，并恢复处理。在往缓冲区中放置了一个字符后，该进程发送notempty条件信号。对消费者函数也可以进行类似的描述。</p>
</blockquote>
<h3 id="使用通知和广播的管程">使用通知和广播的管程</h3>
<p>Hoare关于管程的定义[HOAR74]要求在条件队列中至少有一个进程，当另一个进程为该条件产生caigna1时，该队列中的一个进程立即运行。因此，产生caigna1的进程必须立即退出管程，或者阻塞在管程上。</p>
<p>这种方法有两个缺陷：</p>
<ul>
<li>如果产生csignal的进程在管程内还没有结束，则需要两个额外的进程切换：阻塞这个进程需要一次切换，当管程可用时恢复这个进程又需要一次切换。</li>
<li>与信号相关的进程调度必须非常可靠。当产生一个csignal时，来自相应条件队列中的一个进程必须立即被激活，调度程序必须确保在激活前没有其他进程进入管程，否则，进程被激活的条件又会改变。</li>
</ul>
<p>因此又开发出了一种不同的管程以解决以上问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count == N)&#123;</span><br><span class="line">        cwait(notfull);          <span class="comment">/*缓冲区满，防止溢出*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    buffer[nextin] = x;</span><br><span class="line">    nextin = (nextin + <span class="number">1</span>) % N;</span><br><span class="line">    count++;          <span class="comment">/*缓冲区中数据项个数加一*/</span></span><br><span class="line">    cnotify(notempty);          <span class="comment">/*通知正在等待的进程*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">        cwait(notempty);          <span class="comment">/*缓冲区空，防止下溢*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = buffer[nextout];</span><br><span class="line">    nextout = (nextout + <span class="number">1</span>) % N;</span><br><span class="line">    count--;          <span class="comment">/*缓冲区中数据项个数减一*/</span></span><br><span class="line">    cnotify(notfull);          <span class="comment">/*通知正在等待的进程*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>csignal原语被 cnotify取代。当一个正在管程中的进程执行cnotify(x)时，它使得x条件队列得到通知，但发信号的进程继续执行。通知的结果是使得位于条件队列头的进程在将来合适的时候且当处理器可用时被恢复执行。但是，由于不能保证在它之前没有其他进程进入管程，因而这个等待进程必须重新检查条件。</p>
<p>if语句被 while循环取代，因此，这个方案导致对条件变量至少多一次额外的检测。作为回报，它不再有额外的进程切换，并且对等待进程在cnotify之后什么时候运行没有任何限制。</p>
</blockquote>
<h2 id="消息传递">消息传递</h2>
<p>进程交互式，必须满足两个基本要求：同步和通信。为实施互斥，进程间需要同步；为了合作，进程间需要交换信息。之前介绍的两种机制（信号量以及管程）可以在单处理器系统以及多处理器系统中实现，但是对于分布式系统而言，没有办法提供支持。此外，管程对编译器有依赖，而很多编程语言的编译器并没有提供对管程的支持（比如gcc）。为此，引入了消息传递。</p>
<p>消息传递的实际功能以一对原语的形式提供：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">send(destination, message)</span><br><span class="line">receive(source, message)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>这是进程间进行消息传递所需要的最小操作集。一个进程以消息(message)的形式给另一个指定的目标(destination)进程发送信息；进程通过执行receive原语接收信息，receive原语中指明发送消息的源进程(source)和消息。</p>
<p>send与receive操作既可以是阻塞操作也可以是非阻塞操作：</p>
<ul>
<li>
<p>阻塞操作：在执行一个指令时，在获得这个指令的结果之前，程序不得向下推进；</p>
</li>
<li>
<p>非阻塞操作：在执行一个指令时，在调用这条指令后，不待指令的结果返回，程序可以立即执行下一条指令的操作方式成为非阻塞方。</p>
</li>
</ul>
<blockquote>
<p>因此对于阻塞send 而言，当程序调用了这条指令后，在send中的消息传送给指定进程之前，程序始终停留在send指令上，不向后推进；</p>
<p>而对于非阻塞send,当程序调用这条指令后，指令马上返回，立即执行后面的指令；</p>
<p>同理，对于receive也是如此，阻塞的receive在收到消息之前，程序停留在这条指令之上不会向下执行，非阻塞receive则是调用指令后，立即向下执行。</p>
</blockquote>
</blockquote>
<h3 id="同步（Synchronization）">同步（Synchronization）</h3>
<p>两个进程间的消息通信隐含着某种同步的信息：只有当一个进程发送消息之后，接收者才能接收消息。</p>
<p>当一个进程执行时，在它发送<code>send</code>或<code>receive</code>原语时，都有阻塞或不阻塞两种状态，因此会有如下四种组合：</p>
<ul>
<li>
<p>无阻塞send，无阻塞receive：</p>
<p>等待消息接收，收到消息后继续执行。</p>
</li>
<li>
<p>阻塞send，阻塞receive：</p>
<p>发送者和接收者都被阻塞，直到信息被送达。（这种情况有时也称做会合(rendezvous)，它考虑到了进程间的紧密同步。）</p>
</li>
<li>
<p>无阻塞send，阻塞receive：</p>
<p>发送者可以继续，但接收者被阻塞直到请求的消息到达。</p>
<blockquote>
<p>这可能是最有用的一种组合，它允许一个进程给各个目标进程尽快地发送一条或多条消息。在继续工作前必须接收到消息的进程将被阻塞，直到这个消息到达。例如，一个服务器进程给其他进程提供服务或资源。</p>
</blockquote>
</li>
<li>
<p>阻塞send，无阻塞receive：</p>
<p>不要求任何一方等待。</p>
</li>
</ul>
<p>对于大多数并发程序设计任务来说：</p>
<ul>
<li>
<p>无阻塞send是最自然的：</p>
<blockquote>
<p>例如，无阻塞send用于请求一个输出操作，如打印，它允许请求进程以消息的形式发出请求，然后继续。无阻塞send存在一个潜在的危险：错误会导致进程重复地产生消息。由于对进程没有阻塞的要求，这些消息可能会消耗系统资源，包括处理器时间和缓冲区空间，从而损害其他进程和操作系统。同时，无阻塞send给程序员增加了负担，由于必须确定消息是否收到，因而进程必须使用应答消息，以证实收到了消息。</p>
</blockquote>
</li>
<li>
<p>阻塞receive是最自然的：</p>
<blockquote>
<p>通常，请求一个消息的进程都需要这个期望的信息才能继续执行下去，但是，如果消息丢失了（这在分布式系统中很可能发生），或者一个进程在发送预期的消息之前失败了，那么接收进程将会无限期地被阻塞下去。这个问题可以通过使用无阻塞receive来解决。但是，该方法的危险是，如果消息的发送在一个进程已经执行了与之相匹配的receive之后，该消息将被丢失。其他可能的方法是允许一个进程在发出receive之前检测是否有消息正在等待，或者允许进程在receive原语中确定多个源进程。如果一个进程正在等待从多个源进程发送来的消息，并且只要有一个消息到达就可以继续下去时，后一种方法是非常有用的。</p>
</blockquote>
</li>
</ul>
<h3 id="寻址（Addressing）">寻址（Addressing）</h3>
<p>显然，在send原语中确定哪个进程接收消息是很有必要的。同样，大多数实现允许接收进程指明消息的来源。</p>
<p>在send和receive原语中确定目标或源进程的方案可分为两类：<strong>直接寻址</strong>（direct addressing）和<strong>间接寻址</strong>（indirect addressing）。</p>
<ul>
<li>
<p>直接寻址：</p>
<p>send原语包含目标进程的标识符，而receive原语有两种处理方式：</p>
<ul>
<li>显示寻址：一个进程必须事先知道希望得到来自哪个源进程的消息，这种方式对于处理并发进程间的合作是非常有效的。</li>
<li>隐式寻址：例如打印机服务器进程将接受来自各个进程的打印请求，对这类应用使用隐式寻址更为有效。（不可能指定所期望的源进程）</li>
</ul>
</li>
<li>
<p>间接寻址：</p>
<p>在这种情况，消息不是直接从发送者发送到接收者，而是发送到一个共享数据结构，该结构由临时保存消息的队列组成，这些队列通常称为<strong>邮箱(mailbox)</strong>。因此，对两个通信进程，一个进程给合适的邮箱发送消息，另一个从邮箱中获得这些消息。</p>
<blockquote>
<p>间接寻址通过解除发送者和接收者之间的耦合关系，在消息的使用上允许更大的灵活性。发送者和接收者之间的关系可以是一对一、多对一、一对多或多对多（如下图）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OSAddressing.png" alt=""></p>
<ul>
<li>一对一的关系允许在两个进程间建立专用的通信链接，这可以把它们之间的交互隔离起来，避免其他进程的错误干扰；</li>
<li>多对一的关系对客户/服务器间的交互非常有用，一个进程给许多别的进程提供服务，这时，信箱常常称为一个端口（port）；</li>
<li>一对多的关系适用于一个发送者和多个接收者，它对于在一组进程间广播一条消息或某些信息的应用程序非常有用；</li>
<li>多对多的关系使得多个服务进程可以对多个客户进程提供服务。</li>
</ul>
<p>进程和信箱的关联可以是静态的，也可以是动态的。端口常常是静态地关联到一个特定的进程上，也就是说，端口是被永久地创建并指定到该进程。（在一对一的关系中就是典型的静态和永久性的关系）</p>
</blockquote>
</li>
</ul>
<h3 id="消息格式">消息格式</h3>
<p>消息的格式取决于消息机制的目标以及该机制是运行在一台计算机上还是分布式系统中。</p>
<blockquote>
<p>对某些操作系统，设计者优先选用短的、固定长度的消息，以减少处理和存储的开销。如果需要传递大量的数据，数据可以放置到一个文件中，消息可以简单地引用该文件。一种更灵活的方法是允许可变长度的消息。</p>
</blockquote>
<p>下图给出了一种操作系统的支持可变长度消息的典型消息格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OS%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.png" alt=""></p>
<blockquote>
<p>该消息被划分成两部分：包含相关信息的消息头和包含实际内容的消息体。</p>
<ul>
<li>消息头用来存放用于控制消息传递的信息。</li>
<li>消息体用来存放进程间进程间通讯的内容。</li>
</ul>
<p>消息头可以包含消息的源和目标的标识符、长度域和判定各种消息类型的类型域，还可能含有一些额外的控制信息。（例如用于创建消息链表的指针域、记录源和目标之间传递的消息的数目、顺序和序号，以及一个优先级域）</p>
</blockquote>
<h3 id="排队原则">排队原则</h3>
<p>最简单的排队原则是先进先出原则，但是当某些消息比其他消息更紧急时，仅有这种原则是不够的。一个可选的原则是允许指定消息的优先级，这可以基于消息的类型或者由发送者指定，另一种选择是允许接收者检查消息队列并选择下一次接收哪个消息。</p>
<h3 id="互斥-2">互斥</h3>
<p>以下代码给出了可用于实施互斥的消息传递方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*program mutualexclusion*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="comment">/*进程数*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> p(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    message msg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        receive (box, msg);</span><br><span class="line">        <span class="comment">/*临界区*/</span>;</span><br><span class="line">        send (box, msg);</span><br><span class="line">        <span class="comment">/*其他部分*/</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">creat <span class="title">mailbox</span> <span class="params">(box)</span></span>;</span><br><span class="line">    send (box, null);</span><br><span class="line">    prabeginc(P(<span class="number">1</span>), P(<span class="number">2</span>),...,P(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>假设使用阻塞 receive原语和无阻塞 send原语，一组并发进程共享一个信箱box，它可供所有进程在发送和接收消息时使用，该信箱被初始化成一个无内容的消息。希望进人临界区的进程首先试图接收一条消息，如果信箱为空，则该进程被阻塞；一旦进程获得消息，它执行它的临界区，然后把该消息放回信箱。因此，消息函数可以看做是在进程之间传递的一个令牌。</p>
<p>上面的解决方案假设有多个进程并发地执行接收操作，则：</p>
<ul>
<li>如果有一条消息，它仅仅被传递给一个进程，其他进程被阻塞。</li>
<li>如果消息队列为空，所有进程被阻塞；当有一条消息可用时，只有一个阻塞进程被激活，并得到这条消息。</li>
</ul>
</blockquote>
<p>作为使用消息传递的另一个例子，以下代码是解决有界缓冲区生产者/消费者问题的一种方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span></span><br><span class="line">    capacity = <span class="comment">/*缓冲区容量*/</span></span><br><span class="line">    null = <span class="comment">/*空消息*/</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*producer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message pmsg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        receive (mayproduce, pmsg);</span><br><span class="line">        pmsg = produce();</span><br><span class="line">        send (mayconsume, pmsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*consumer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    message cmsg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        receive (mayconsume, cmsg);</span><br><span class="line">        consume (cmsg);</span><br><span class="line">        send (mayproduce, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create_mailbox (mayproduce);</span><br><span class="line">    create_mailbox (mayconsume);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= capacity; i++)&#123;</span><br><span class="line">        send (mayproduce, null);</span><br><span class="line">    &#125;</span><br><span class="line">    parbegin (producer, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：</p>
<p>它使用了两个信箱。当生产者产生了数据，它作为消息被发送到信箱mayconsume，只要该信箱中有一条消息，消费者就可以开始消费。从此之后mayconsume作为缓冲区，缓冲区中的数据被组织成消息队列，缓冲区的大小由全局变量capacity确定。信箱mayproduce最初填满了空消息，空消息的数量等于信箱的容量，每次生产使得mayproduce中的消息数缩小，每次消费使得mayproduce中的消息数增长。</p>
<p>这种方法非常灵活，可以有多个生产者和消费者，只要它们都访问这两个信箱即可。系统甚至可以是分布式系统，所有生产者进程和mayproduce信箱在一个站点上，所有消费者进程和mayconsume信箱在另一个站点上。</p>
</blockquote>
<hr>
<h1>后记</h1>
<p>本篇已完结</p>
<p>（如有修改或补充欢迎评论）</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/wechat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/03/14/操作系统/操作系统学习笔记-计算机系统概述/" title="操作系统学习笔记-计算机系统概述"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-14</div><div class="title">操作系统学习笔记-计算机系统概述</div></div></a></div><div><a href="/2021/03/28/操作系统/操作系统学习笔记/" title="操作系统学习笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-28</div><div class="title">操作系统学习笔记</div></div></a></div><div><a href="/2021/06/02/操作系统/操作系统学习笔记-I-O管理和磁盘调度/" title="操作系统学习笔记-I/O管理和磁盘调度"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">操作系统学习笔记-I/O管理和磁盘调度</div></div></a></div><div><a href="/2021/05/23/操作系统/操作系统学习笔记-内存管理/" title="操作系统学习笔记-内存管理"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-23</div><div class="title">操作系统学习笔记-内存管理</div></div></a></div><div><a href="/2021/04/25/操作系统/操作系统学习笔记-信号量相关问题/" title="操作系统学习笔记-信号量相关问题"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-25</div><div class="title">操作系统学习笔记-信号量相关问题</div></div></a></div><div><a href="/2021/05/30/操作系统/操作系统学习笔记-单处理器调度/" title="操作系统学习笔记-单处理器调度"><img class="cover" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/OperatingSystemscover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-30</div><div class="title">操作系统学习笔记-单处理器调度</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">花猪</div><div class="author-info__description">此站点就暂时停留在秋天了吧</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/CNhuazhu"><i class="fab fa-github"></i><span>我的github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CNhuazhu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">花猪在此欢迎您光临小破站 (՞•Ꙫ•՞) <br><b>此站点已暂停更新！！！！</b><br><br>  <b><i>本站已部署至云服务器👇</i></b>：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top">http://cnhuazhu.top</a> <br><br>  <b><i>github地址（暂停更新）</i></b>：<a href="https://cnhuazhu.github.io/">https://cnhuazhu.github.io/</a> <br> <b><i>码云地址（暂停更新）</i></b>：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cnhuazhu.gitee.io">https://cnhuazhu.gitee.io</a> <br><br>  本站主题：Butterfly 3.7.8 <br> <img src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/pig.gif"></div><timing></timing></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第五章：并发性：互斥和同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">并发的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B%E5%8F%8A%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">简单案例及分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">竞争条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B3%E6%B3%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">操作系统关注的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%A4%E4%BA%92"><span class="toc-number">2.1.4.</span> <span class="toc-text">进程的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">进程间的资源竞争</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%BF%87%E5%85%B1%E4%BA%AB%E5%90%88%E4%BD%9C"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">进程间通过共享合作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%BF%87%E9%80%9A%E4%BF%A1%E5%90%88%E4%BD%9C"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">进程间通过通信合作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">2.1.5.</span> <span class="toc-text">互斥的要求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%EF%BC%9A%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.2.</span> <span class="toc-text">互斥：硬件的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%A6%81%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">中断禁用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">专用机器指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#compare-and-swap%EF%BC%88%E6%AF%94%E8%BE%83%E5%92%8C%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">compare_and_swap（比较和交换指令）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exchange%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4%EF%BC%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">exchange（交换指令）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">信号量的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">信号量的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.4.</span> <span class="toc-text">信号量原语的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.5.</span> <span class="toc-text">二元信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E3%80%81%E5%BC%B1%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">2.3.6.</span> <span class="toc-text">强、弱信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5"><span class="toc-number">2.3.7.</span> <span class="toc-text">互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.8.</span> <span class="toc-text">信号量问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.9.</span> <span class="toc-text">信号量的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">使用信号的管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%E5%92%8C%E5%B9%BF%E6%92%AD%E7%9A%84%E7%AE%A1%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">使用通知和广播的管程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">2.5.</span> <span class="toc-text">消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%88Synchronization%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">同步（Synchronization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%EF%BC%88Addressing%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">寻址（Addressing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">消息格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E9%98%9F%E5%8E%9F%E5%88%99"><span class="toc-number">2.5.4.</span> <span class="toc-text">排队原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5-2"><span class="toc-number">2.5.5.</span> <span class="toc-text">互斥</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">后记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/02/NodeJS/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAexpress%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="快速搭建一个express服务器"><img src="https://gitee.com/CNhuazhu/tu-chuang1/raw/master/img-blog/Node_Express_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速搭建一个express服务器"/></a><div class="content"><a class="title" href="/2021/11/02/NodeJS/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAexpress%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="快速搭建一个express服务器">快速搭建一个express服务器</a><time datetime="2021-11-02T00:39:53.000Z" title="发表于 2021-11-02 08:39:53">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/28/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Nginx-uWSGI-Flask%E9%83%A8%E7%BD%B2%E8%87%B3Ubuntu/" title="Nginx+uWSGI+Flask部署至Ubuntu"><img src="https://gitee.com/CNhuazhu/tu-chuang1/raw/master/img-blog/Ubuntu_Server_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx+uWSGI+Flask部署至Ubuntu"/></a><div class="content"><a class="title" href="/2021/10/28/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Nginx-uWSGI-Flask%E9%83%A8%E7%BD%B2%E8%87%B3Ubuntu/" title="Nginx+uWSGI+Flask部署至Ubuntu">Nginx+uWSGI+Flask部署至Ubuntu</a><time datetime="2021-10-28T03:01:09.000Z" title="发表于 2021-10-28 11:01:09">2021-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/18/Xftp%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Xftp传输文件失败解决方案"><img src="https://gitee.com/CNhuazhu/tu-chuang1/raw/master/img-blog/Xftp_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Xftp传输文件失败解决方案"/></a><div class="content"><a class="title" href="/2021/10/18/Xftp%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Xftp传输文件失败解决方案">Xftp传输文件失败解决方案</a><time datetime="2021-10-18T09:50:16.000Z" title="发表于 2021-10-18 17:50:16">2021-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Hexo%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E7%BB%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E5%BC%95%E5%AF%BC%E9%A1%B5%E5%8F%8A%E5%88%86%E7%AB%99/" title="Hexo部署至服务器（续）——建立引导页及分站"><img src="https://gitee.com/CNhuazhu/tu-chuang1/raw/master/img-blog/Ubuntu_Server_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo部署至服务器（续）——建立引导页及分站"/></a><div class="content"><a class="title" href="/2021/10/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Hexo%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E7%BB%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BB%BA%E7%AB%8B%E5%BC%95%E5%AF%BC%E9%A1%B5%E5%8F%8A%E5%88%86%E7%AB%99/" title="Hexo部署至服务器（续）——建立引导页及分站">Hexo部署至服务器（续）——建立引导页及分站</a><time datetime="2021-10-13T13:49:12.000Z" title="发表于 2021-10-13 21:49:12">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Hexo%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu-20-04%EF%BC%89/" title="Hexo部署至服务器（Ubuntu 20.04）"><img src="https://gitee.com/CNhuazhu/tu-chuang1/raw/master/img-blog/Ubuntu_Server_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo部署至服务器（Ubuntu 20.04）"/></a><div class="content"><a class="title" href="/2021/10/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu%EF%BC%89/Hexo%E9%83%A8%E7%BD%B2%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88Ubuntu-20-04%EF%BC%89/" title="Hexo部署至服务器（Ubuntu 20.04）">Hexo部署至服务器（Ubuntu 20.04）</a><time datetime="2021-10-12T07:13:40.000Z" title="发表于 2021-10-12 15:13:40">2021-10-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By 花猪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://beian.miit.gov.cn/">蜀ICP备2021026748号</a><br>感谢光临<a target="_blank" rel="noopener external nofollow noreferrer" href="http://cnhuazhu.top/" style="text-decoration:underline">小破站</a>,欢迎您提出宝贵的意见！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 3000);</script></div><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', '', 'katex-wrap')
  })
})()</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hexo-1g41404w9f800e94',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hexo-1g41404w9f800e94',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VHoX95KsBQSMyzEc3TdpmBkF-MdYXbMMI',
      appKey: 'qnwObDMbgMEKnu1Gp8tk7PYJ',
      placeholder: '欢迎留下你的评论（昵称和邮箱为必填项）',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script src="/js/ip_content.js"></script><script src="/js/timing.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script src="/js/footer.js"></script><script src="/js/ginkgo-leaf.js"></script><script id="canvas_nest" defer="defer" color="0,0,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="pjax-reload"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInLeft');
    arr[i].setAttribute('data-wow-duration', '600ms');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__fadeInRightBig');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer="defer" src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer="defer" src="/js/wow_init.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
                        function butterfly_swiper_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/28/Hexo魔改/Hexo魔改记录/" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage4.jpg" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-28</span><a class="blog-slider__title" href="2021/03/28/Hexo魔改/Hexo魔改记录/" alt="">Hexo魔改记录</a><div class="blog-slider__text">Hexo魔改记录</div><a class="blog-slider__button" href="2021/03/28/Hexo魔改/Hexo魔改记录/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/08/02/Vue/Vue学习笔记/" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage5.jpg" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-08-02</span><a class="blog-slider__title" href="2021/08/02/Vue/Vue学习笔记/" alt="">Vue学习笔记</a><div class="blog-slider__text">本文将介绍Vue的基础语法</div><a class="blog-slider__button" href="2021/08/02/Vue/Vue学习笔记/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/28/Java/Java学习记录/" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage8.jpg" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-28</span><a class="blog-slider__title" href="2021/03/28/Java/Java学习记录/" alt="">Java学习记录</a><div class="blog-slider__text">Java学习记录</div><a class="blog-slider__button" href="2021/03/28/Java/Java学习记录/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/28/操作系统/操作系统学习笔记/" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage7.jpg" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-28</span><a class="blog-slider__title" href="2021/03/28/操作系统/操作系统学习笔记/" alt="">操作系统学习笔记</a><div class="blog-slider__text">记录操作系统学习历程</div><a class="blog-slider__button" href="2021/03/28/操作系统/操作系统学习笔记/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2021/03/28/计算机网络/计算机网络学习笔记/" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/CNhuazhu/Image/RotatingImage3.jpg" alt=""/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-03-28</span><a class="blog-slider__title" href="2021/03/28/计算机网络/计算机网络学习笔记/" alt="">计算机网络学习笔记</a><div class="blog-slider__text">记录计算机网络学习历程</div><a class="blog-slider__button" href="2021/03/28/计算机网络/计算机网络学习笔记/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
                          console.log('已挂载butterfly_swiper')
                          // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
                          }
                        if( document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
                        butterfly_swiper_injector_config()
                        }
                      </script><script defer src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"superSample":2,"width":200,"height":400,"position":"left","hOffset":0,"vOffset":-105},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>